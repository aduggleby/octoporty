// Sha512CryptVerifier.cs
// Verifies passwords against SHA-512 crypt hashes ($6$salt$hash format).
// Implements the SHA-512 crypt algorithm per crypt(3) specification.
// Compatible with hashes generated by: openssl passwd -6 "password"

using System.Buffers;
using System.Security.Cryptography;
using System.Text;

namespace Octoporty.Shared.Security;

/// <summary>
/// Verifies passwords against SHA-512 crypt hashes ($6$ format).
/// This is a standard Unix password hashing format supported by glibc crypt().
/// </summary>
public static class Sha512CryptVerifier
{
    // SHA-512 crypt uses base64 with a custom alphabet (not standard base64)
    private const string Base64Alphabet = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    private const int DefaultRounds = 5000;
    private const int MinRounds = 1000;
    private const int MaxRounds = 999_999_999;
    private const int Sha512DigestLength = 64;

    /// <summary>
    /// Verifies a password against a SHA-512 crypt hash.
    /// </summary>
    /// <param name="password">The plaintext password to verify.</param>
    /// <param name="hash">The SHA-512 crypt hash (e.g., $6$salt$hash...).</param>
    /// <returns>True if the password matches; false otherwise.</returns>
    public static bool Verify(string password, string hash)
    {
        if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(hash))
            return false;

        // Parse the hash to extract components
        if (!TryParseHash(hash, out var rounds, out var salt, out var expectedHash))
            return false;

        // Compute hash of the provided password with the same salt and rounds
        var computedHash = ComputeHash(password, salt, rounds);

        // Constant-time comparison to prevent timing attacks
        var expected = Encoding.ASCII.GetBytes(expectedHash);
        var computed = Encoding.ASCII.GetBytes(computedHash);

        if (expected.Length != computed.Length)
            return false;

        return CryptographicOperations.FixedTimeEquals(expected, computed);
    }

    /// <summary>
    /// Parses a SHA-512 crypt hash string into its components.
    /// Supports both $6$salt$hash and $6$rounds=N$salt$hash formats.
    /// </summary>
    private static bool TryParseHash(string hash, out int rounds, out string salt, out string hashValue)
    {
        rounds = DefaultRounds;
        salt = string.Empty;
        hashValue = string.Empty;

        if (!hash.StartsWith("$6$"))
            return false;

        var remainder = hash.AsSpan(3); // Skip "$6$"

        // Check for explicit rounds parameter
        if (remainder.StartsWith("rounds="))
        {
            remainder = remainder.Slice(7); // Skip "rounds="
            var dollarIndex = remainder.IndexOf('$');
            if (dollarIndex < 0)
                return false;

            if (!int.TryParse(remainder.Slice(0, dollarIndex), out rounds))
                return false;

            // Clamp rounds to valid range
            rounds = Math.Clamp(rounds, MinRounds, MaxRounds);

            remainder = remainder.Slice(dollarIndex + 1);
        }

        // Find salt/hash separator
        var lastDollar = remainder.IndexOf('$');
        if (lastDollar < 0 || lastDollar > 16)
            return false; // Salt must be 1-16 characters

        salt = remainder.Slice(0, lastDollar).ToString();
        hashValue = remainder.Slice(lastDollar + 1).ToString();

        // Hash should be 86 characters for SHA-512
        return hashValue.Length == 86;
    }

    /// <summary>
    /// Computes the SHA-512 crypt hash of a password with the given salt and rounds.
    /// This implements the algorithm specified in crypt(3).
    /// </summary>
    private static string ComputeHash(string password, string salt, int rounds)
    {
        var passwordBytes = Encoding.UTF8.GetBytes(password);
        var saltBytes = Encoding.UTF8.GetBytes(salt);

        // Step 1-8: Compute digest B
        // B = SHA512(password + salt + password)
        var digestB = new byte[Sha512DigestLength];
        using (var sha = SHA512.Create())
        {
            sha.TransformBlock(passwordBytes, 0, passwordBytes.Length, null, 0);
            sha.TransformBlock(saltBytes, 0, saltBytes.Length, null, 0);
            sha.TransformFinalBlock(passwordBytes, 0, passwordBytes.Length);
            digestB = sha.Hash!;
        }

        // Step 9-12: Compute digest A
        // Start with password + salt
        using var streamA = new MemoryStream();
        streamA.Write(passwordBytes);
        streamA.Write(saltBytes);

        // Add bytes from B based on password length
        var remaining = passwordBytes.Length;
        while (remaining > Sha512DigestLength)
        {
            streamA.Write(digestB);
            remaining -= Sha512DigestLength;
        }
        streamA.Write(digestB, 0, remaining);

        // Add alternating null bytes or first byte of password based on password length bits
        var length = passwordBytes.Length;
        while (length > 0)
        {
            if ((length & 1) != 0)
                streamA.Write(digestB);
            else
                streamA.Write(passwordBytes);
            length >>= 1;
        }

        var digestA = SHA512.HashData(streamA.ToArray());

        // Step 13-15: Compute digest DP (password repeated)
        using var streamDP = new MemoryStream();
        for (var i = 0; i < passwordBytes.Length; i++)
            streamDP.Write(passwordBytes);

        var digestDP = SHA512.HashData(streamDP.ToArray());

        // Step 16: Create sequence P from DP
        var sequenceP = new byte[passwordBytes.Length];
        for (var i = 0; i < passwordBytes.Length; i++)
            sequenceP[i] = digestDP[i % Sha512DigestLength];

        // Step 17-19: Compute digest DS (salt repeated based on 16 + first byte of A)
        using var streamDS = new MemoryStream();
        var dsCount = 16 + digestA[0];
        for (var i = 0; i < dsCount; i++)
            streamDS.Write(saltBytes);

        var digestDS = SHA512.HashData(streamDS.ToArray());

        // Step 20: Create sequence S from DS
        var sequenceS = new byte[saltBytes.Length];
        for (var i = 0; i < saltBytes.Length; i++)
            sequenceS[i] = digestDS[i % Sha512DigestLength];

        // Step 21: Perform rounds iterations
        var digestC = digestA;
        for (var i = 0; i < rounds; i++)
        {
            using var streamC = new MemoryStream();

            if ((i & 1) != 0)
                streamC.Write(sequenceP);
            else
                streamC.Write(digestC);

            if (i % 3 != 0)
                streamC.Write(sequenceS);

            if (i % 7 != 0)
                streamC.Write(sequenceP);

            if ((i & 1) != 0)
                streamC.Write(digestC);
            else
                streamC.Write(sequenceP);

            digestC = SHA512.HashData(streamC.ToArray());
        }

        // Step 22: Encode the final digest using the custom base64 alphabet
        return EncodeBase64(digestC);
    }

    /// <summary>
    /// Encodes a SHA-512 digest using the crypt-specific base64 encoding.
    /// The byte order is permuted according to the crypt(3) specification.
    /// </summary>
    private static string EncodeBase64(byte[] digest)
    {
        // SHA-512 crypt uses a specific permutation of the digest bytes
        // This permutation ensures that related input bits are spread across the output
        int[] permutation =
        [
            0, 21, 42, 22, 43, 1, 44, 2, 23, 3, 24, 45,
            25, 46, 4, 47, 5, 26, 6, 27, 48, 28, 49, 7,
            50, 8, 29, 9, 30, 51, 31, 52, 10, 53, 11, 32,
            12, 33, 54, 34, 55, 13, 56, 14, 35, 15, 36, 57,
            37, 58, 16, 59, 17, 38, 18, 39, 60, 40, 61, 19,
            62, 20, 41, 63
        ];

        var result = new StringBuilder(86);

        // Process 3 bytes at a time, producing 4 base64 characters
        for (var i = 0; i < 63; i += 3)
        {
            var b0 = digest[permutation[i]];
            var b1 = digest[permutation[i + 1]];
            var b2 = digest[permutation[i + 2]];

            var value = (b0 << 16) | (b1 << 8) | b2;

            result.Append(Base64Alphabet[value & 0x3F]);
            result.Append(Base64Alphabet[(value >> 6) & 0x3F]);
            result.Append(Base64Alphabet[(value >> 12) & 0x3F]);
            result.Append(Base64Alphabet[(value >> 18) & 0x3F]);
        }

        // Last byte (index 63) produces 2 characters
        var lastByte = digest[permutation[63]];
        result.Append(Base64Alphabet[lastByte & 0x3F]);
        result.Append(Base64Alphabet[(lastByte >> 6) & 0x3F]);

        return result.ToString();
    }
}
